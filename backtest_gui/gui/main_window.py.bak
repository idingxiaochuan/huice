#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
主窗口模块
"""
import os
import sys
import traceback
from datetime import datetime, timedelta
import pandas as pd  # 导入pandas库
import numpy as np
import json
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from PyQt5.QtWidgets import (
    QMainWindow, QVBoxLayout, QHBoxLayout, QWidget, QFrame, QLabel, 
    QPushButton, QComboBox, QDateEdit, QScrollArea, QTabWidget,
    QMessageBox, QLineEdit, QStatusBar, QFileDialog, QAction,
    QMenuBar, QMenu, QGridLayout, QToolBar, QSplitter, 
    QSpacerItem, QSizePolicy, QApplication
)
from PyQt5.QtCore import Qt, QDateTime, QDate, pyqtSignal, pyqtSlot, QTimer, QSize, QThread
from PyQt5.QtGui import QColor, QBrush, QDoubleValidator

from backtest_gui.strategy.band_strategy import BandStrategy
from backtest_gui.execution.trade_executor import TradeExecutor
from backtest_gui.utils.backtest_data_manager import BacktestDataManager
from backtest_gui.gui.chart_widget import ChartWidget
from backtest_gui.gui.trade_panel import TradePanel
from backtest_gui.utils.db_connector import DBConnector
from backtest_gui.utils.backtest_data_manager import BacktestDataManager
from backtest_gui.utils.backtest_engine import BacktestEngine
from backtest_gui.utils.trade_executor import TradeExecutor

class MainWindow(QMainWindow):
    """波段交易回测系统主窗口"""
    
    def __init__(self, config=None):
        """初始化主窗口
        
        Args:
            config: 配置对象
        """
        super().__init__()
        
        # 保存配置
        self.config = config
        
        # 初始化数据库连接器
        try:
            from backtest_gui.utils.db_connector import DBConnector
            self.db_connector = DBConnector()
        except Exception as e:
            print(f"初始化数据库连接器错误: {str(e)}")
            traceback.print_exc()
            self.db_connector = None
        
        # 初始化数据管理器
        self.data_loader = BacktestDataManager(self.db_connector)
        
        # 创建状态栏
        self.statusBar = QStatusBar()
        self.setStatusBar(self.statusBar)
        
        try:
            # 初始化UI
            self.init_ui()
            
            # 显示状态信息
            self.statusBar.showMessage("数据库连接成功")
        except Exception as e:
            print(f"初始化错误: {str(e)}")
            traceback.print_exc()
        
    def init_ui(self):
        """初始化用户界面"""
        try:
            # 设置窗口标题
            self.setWindowTitle("行情回测模块")
            self.setMinimumSize(1200, 800)
            
            # 创建中央部件
            central_widget = QWidget()
            self.setCentralWidget(central_widget)
            
            # 创建主布局
            main_layout = QVBoxLayout(central_widget)
            main_layout.setContentsMargins(10, 10, 10, 10)
            main_layout.setSpacing(10)
            
            # 创建顶部控制面板
            control_panel = self.create_control_panel()
            main_layout.addWidget(control_panel)
            
            # 创建策略容器 - 可滚动区域，用于容纳多个回测模块
            self.strategy_scroll_area = QScrollArea()
            self.strategy_scroll_area.setWidgetResizable(True)
            self.strategy_scroll_area.setFrameShape(QFrame.NoFrame)
            
            # 创建内部容器widget
            self.strategy_container = QWidget()
            self.strategy_container_layout = QVBoxLayout(self.strategy_container)
            self.strategy_container_layout.setContentsMargins(0, 0, 0, 0)
            self.strategy_container_layout.setSpacing(10)
            self.strategy_container_layout.addStretch(1)  # 添加弹性空间让内容靠上
            
            # 设置滚动区域的内容
            self.strategy_scroll_area.setWidget(self.strategy_container)
            
            # 添加滚动区域到主布局
            main_layout.addWidget(self.strategy_scroll_area)
            main_layout.setStretchFactor(control_panel, 0)  # 控制面板不伸展
            main_layout.setStretchFactor(self.strategy_scroll_area, 1)  # 内容区域可伸展
            
            # 加载基金列表
            self.load_fund_list()
            
        except Exception as e:
            print(f"初始化界面错误: {str(e)}")
            traceback.print_exc()
            
    def create_control_panel(self):
        """创建顶部控制面板"""
        panel = QWidget()
        panel.setMaximumHeight(50)  # 设置最大高度
        panel.setStyleSheet("""
            QLabel {
                font-size: 12px;
                margin-right: 2px;
            }
            QComboBox, QDateEdit {
                border: 1px solid #CCCCCC;
                border-radius: 3px;
                padding: 2px 5px;
                background: white;
                min-height: 25px;
            }
            QPushButton {
                background-color: #f0f0f0;
                border: 1px solid #CCCCCC;
                border-radius: 3px;
                padding: 5px 10px;
                min-height: 25px;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
            }
            QPushButton#startButton {
                background-color: #4CAF50;
                color: white;
            }
            QPushButton#startButton:hover {
                background-color: #45a049;
            }
        """)
        
        # 创建水平布局
        layout = QHBoxLayout(panel)
        layout.setContentsMargins(10, 5, 10, 5)
        layout.setSpacing(12)  # 设置组件之间的间距
        
        # 1. 基金名称
        fund_label = QLabel("基金名称")
        layout.addWidget(fund_label)
        
        fund_combo = QComboBox()
        fund_combo.addItem("恒生ETF")
        fund_combo.setFixedWidth(180)
        fund_combo.currentTextChanged.connect(self.on_fund_changed)
        layout.addWidget(fund_combo)
        
        # 2. 数据粒度
        data_label = QLabel("数据粒度")
        layout.addWidget(data_label)
        
        data_combo = QComboBox()
        data_combo.addItem("1min")
        data_combo.addItem("5min")
        data_combo.addItem("15min")
        data_combo.addItem("30min")
        data_combo.addItem("60min")
        data_combo.addItem("日线")
        data_combo.setFixedWidth(60)
        data_combo.currentTextChanged.connect(self.on_data_granularity_changed) # 连接数据粒度变化信号
        layout.addWidget(data_combo)
        
        # 3. 波段策略
        strategy_label = QLabel("波段策略")
        layout.addWidget(strategy_label)
        
        strategy_combo = QComboBox()
        strategy_combo.addItem("恒生")
        strategy_combo.setFixedWidth(80)
        strategy_combo.currentTextChanged.connect(self.on_strategy_changed)
        layout.addWidget(strategy_combo)
        
        # 4. 开始日期
        start_label = QLabel("开始日期")
        layout.addWidget(start_label)
        
        start_date = QDateEdit()
        start_date.setDisplayFormat("yyyy-MM-dd")
        start_date.setDate(QDate(2021, 12, 1))
        start_date.setCalendarPopup(True)
        start_date.setFixedWidth(100)
        layout.addWidget(start_date)
        
        # 5. 结束日期
        end_label = QLabel("结束日期")
        layout.addWidget(end_label)
        
        end_date = QDateEdit()
        end_date.setDisplayFormat("yyyy-MM-dd")
        end_date.setDate(QDate(2022, 12, 1))
        end_date.setCalendarPopup(True)
        end_date.setFixedWidth(100)
        layout.addWidget(end_date)
        
        # 添加弹性空间
        layout.addStretch(1)
        
        # 6. 添加策略按钮
        add_strategy_btn = QPushButton("添加策略")
        add_strategy_btn.setFixedWidth(100)
        add_strategy_btn.clicked.connect(self.on_add_strategy)
        layout.addWidget(add_strategy_btn)
        
        # 7. 开始回测按钮
        start_backtest_btn = QPushButton("开始回测")
        start_backtest_btn.setObjectName("startButton")  # 设置对象名以便应用特定样式
        start_backtest_btn.setFixedWidth(100)
        start_backtest_btn.clicked.connect(self.on_start_backtest)
        layout.addWidget(start_backtest_btn)
        
        # 保存引用
        self.fund_combo = fund_combo
        self.data_combo = data_combo
        self.strategy_combo = strategy_combo
        self.start_date_edit = start_date
        self.end_date_edit = end_date
        self.add_strategy_btn = add_strategy_btn
        self.start_backtest_btn = start_backtest_btn
        
        return panel
        
    def on_fund_changed(self, fund_name):
        """基金名称变更事件处理"""
        try:
            self.statusBar.showMessage(f"已选择基金: {fund_name}")
            
            # 加载该基金对应的策略
            self.load_strategies_for_fund(fund_name)
        except Exception as e:
            print(f"基金变更处理错误: {str(e)}")
            traceback.print_exc()
    
    def on_strategy_changed(self, strategy_name):
        """策略选择变更时的回调"""
        try:
            self.statusBar.showMessage(f"已选择策略: {strategy_name}")
        except Exception as e:
            print(f"策略变更处理错误: {str(e)}")
            traceback.print_exc()
    
    def create_subfunc_panel(self):
        """创建子功能面板"""
        try:
            # 创建子功能面板
            subfunc_panel = QWidget()
            subfunc_layout = QVBoxLayout(subfunc_panel)
            subfunc_layout.setContentsMargins(0, 0, 0, 0)
            
            # 添加按钮
            self.predict_button = QPushButton("预测分析")
            self.predict_button.clicked.connect(self.open_prediction_window)
            subfunc_layout.addWidget(self.predict_button)
            
            # 添加交易报告按钮
            self.report_button = QPushButton("交易报告")
            self.report_button.clicked.connect(self.open_trade_report_window)
            subfunc_layout.addWidget(self.report_button)
            
            # 添加更多按钮...
            
            # 添加伸缩项
            subfunc_layout.addStretch()
            
            return subfunc_panel
            
        except Exception as e:
            print(f"创建子功能面板错误: {str(e)}")
            traceback.print_exc()
            return QWidget()
            
    def open_prediction_window(self):
        """打开预测分析窗口"""
        try:
            QMessageBox.information(self, "预测分析", "此功能将在后续版本中实现")
        except Exception as e:
            print(f"打开预测分析窗口错误: {str(e)}")
            traceback.print_exc()
            
    def open_trade_report_window(self):
        """打开交易报告窗口"""
        try:
            from backtest_gui.gui.trade_report_window import TradeReportWindow
            
            # 创建交易报告窗口
            report_window = TradeReportWindow(self.db_connector)
            report_window.show()
            
            # 保存窗口引用，防止被垃圾回收
            self.report_window = report_window
            
        except Exception as e:
            print(f"打开交易报告窗口错误: {str(e)}")
            traceback.print_exc()
            QMessageBox.warning(self, "打开错误", f"打开交易报告窗口失败: {str(e)}")
    
    def load_fund_list(self):
        """加载基金列表"""
        try:
            # 清空基金下拉框
            self.fund_combo.clear()
            
            # 尝试从数据库加载基金列表
            if self.db_connector:
                conn = None
                try:
                    conn = self.db_connector.get_connection()
                    cursor = conn.cursor()
                    
                    # 查询基金列表 - 优先从fund_info表获取
                    cursor.execute("""
                        SELECT DISTINCT fi.fund_code, fi.fund_name 
                        FROM fund_info fi
                        JOIN stock_quotes sq ON fi.fund_code = sq.fund_code
                        ORDER BY fi.fund_code
                    """)
                    
                    funds = cursor.fetchall()
                    
                    # 如果fund_info表没有数据，则从stock_quotes表获取
                    if not funds:
                        cursor.execute("""
                            SELECT DISTINCT fund_code 
                            FROM stock_quotes
                            ORDER BY fund_code
                        """)
                        funds = [(row[0], row[0]) for row in cursor.fetchall()]
                    
                    # 添加基金到下拉框
                    for fund_code, fund_name in funds:
                        # 添加市场后缀
                        if fund_code.startswith('5') or fund_code.startswith('6'):
                            display_code = f"{fund_code}.SH"
                        else:
                            display_code = f"{fund_code}.SZ"
                        
                        # 如果有名称，则显示代码和名称
                        if fund_name and fund_name != fund_code:
                            display_text = f"{display_code} - {fund_name}"
                        else:
                            display_text = display_code
                        
                        # 将原始代码存储为用户数据，以便后续使用
                        self.fund_combo.addItem(display_text, fund_code)
                    
                    print(f"加载了 {self.fund_combo.count()} 个基金")
                    
                    # 如果有基金，选择第一个并加载相关数据
                    if self.fund_combo.count() > 0:
                        self.on_fund_changed(self.fund_combo.currentText())
                        
                finally:
                    if conn:
                        self.db_connector.release_connection(conn)
            
            # 如果数据库加载失败或没有基金，添加示例基金
            if self.fund_combo.count() == 0:
                self.fund_combo.addItem("恒生ETF")
                    
        except Exception as e:
            print(f"加载基金列表错误: {str(e)}")
            traceback.print_exc()
            
    def load_strategies_for_fund(self, fund_name):
        """加载指定基金的策略列表
        
        Args:
            fund_name: 基金名称
        """
        try:
            # 清空策略下拉框
            self.strategy_combo.clear()
            
            # 获取基金代码（去除市场后缀）
            fund_code = self.fund_combo.currentData()
            if not fund_code:
                fund_code = fund_name.split('.')[0]
            
            # 尝试从数据库加载策略列表
            if self.db_connector:
                conn = None
                try:
                    conn = self.db_connector.get_connection()
                    cursor = conn.cursor()
                    
                    # 查询与该基金绑定的策略
                    cursor.execute("""
                        SELECT bs.id, bs.name
                        FROM band_strategies bs
                        JOIN fund_strategy_bindings fsb ON bs.id = fsb.strategy_id
                        WHERE fsb.fund_code = %s
                        ORDER BY fsb.is_default DESC, bs.name
                    """, (fund_code,))
                    
                    strategies = cursor.fetchall()
                    
                    # 如果没有绑定的策略，则加载所有策略
                    if not strategies:
                        cursor.execute("""
                            SELECT id, name
                            FROM band_strategies
                            ORDER BY name
                        """)
                        strategies = cursor.fetchall()
                    
                    # 添加策略到下拉框
                    for strategy_id, strategy_name in strategies:
                        self.strategy_combo.addItem(strategy_name, strategy_id)
                    
                    print(f"加载了 {self.strategy_combo.count()} 个策略")
                    
                finally:
                    if conn:
                        self.db_connector.release_connection(conn)
            
            # 如果数据库加载失败或没有策略，添加示例策略
            if self.strategy_combo.count() == 0:
                self.strategy_combo.addItem("恒生")
            
            # 加载该基金的数据粒度选项
            self.load_data_granularity_for_fund(fund_code)
            
            # 加载该基金的日期范围
            self.load_date_range_for_fund(fund_code)
            
        except Exception as e:
            print(f"加载策略列表错误: {str(e)}")
            traceback.print_exc()
            
    def load_data_granularity_for_fund(self, fund_code):
        """加载指定基金的数据粒度选项
        
        Args:
            fund_code: 基金代码
        """
        try:
            # 清空数据粒度下拉框
            self.data_combo.clear()
            
            # 默认数据粒度选项
            default_granularities = ["1min", "5min", "15min", "30min", "60min", "日线"]
            
            # 尝试从数据库加载数据粒度
            if self.db_connector:
                conn = None
                try:
                    conn = self.db_connector.get_connection()
                    cursor = conn.cursor()
                    
                    # 查询该基金的可用数据粒度
                    cursor.execute("""
                        SELECT DISTINCT data_level
                        FROM stock_quotes
                        WHERE fund_code = %s
                        ORDER BY data_level
                    """, (fund_code,))
                    
                    granularities = [row[0] for row in cursor.fetchall()]
                    
                    # 如果有数据粒度，添加到下拉框
                    if granularities:
                        # 自定义排序顺序
                        ordered_granularities = []
                        for g in ["1min", "5min", "15min", "30min", "60min", "day"]:
                            if g in granularities:
                                ordered_granularities.append(g)
                        
                        # 添加任何其他可能的粒度
                        for g in granularities:
                            if g not in ordered_granularities:
                                ordered_granularities.append(g)
                        
                        # 添加到下拉框
                        for granularity in ordered_granularities:
                            # 将'day'显示为'日线'
                            display_text = "日线" if granularity == "day" else granularity
                            self.data_combo.addItem(display_text, granularity)
                    else:
                        # 如果没有数据粒度，使用默认选项
                        for granularity in default_granularities:
                            self.data_combo.addItem(granularity)
                    
                finally:
                    if conn:
                        self.db_connector.release_connection(conn)
            else:
                # 如果数据库连接失败，使用默认选项
                for granularity in default_granularities:
                    self.data_combo.addItem(granularity)
                    
        except Exception as e:
            print(f"加载数据粒度错误: {str(e)}")
            traceback.print_exc()
            
            # 出错时使用默认选项
            for granularity in ["1min", "5min", "15min", "30min", "60min", "日线"]:
                self.data_combo.addItem(granularity)
                
    def load_date_range_for_fund(self, fund_code):
        """加载指定基金的日期范围
        
        Args:
            fund_code: 基金代码
        """
        try:
            # 获取当前选择的数据粒度
            data_level = self.data_combo.currentData()
            if not data_level:
                data_level = self.data_combo.currentText()
                if data_level == "日线":
                    data_level = "day"
            
            # 尝试从数据库加载日期范围
            if self.db_connector:
                conn = None
                try:
                    conn = self.db_connector.get_connection()
                    cursor = conn.cursor()
                    
                    # 查询该基金在指定数据粒度下的日期范围
                    cursor.execute("""
                        SELECT MIN(date), MAX(date)
                        FROM stock_quotes
                        WHERE fund_code = %s AND data_level = %s
                    """, (fund_code, data_level))
                    
                    result = cursor.fetchone()
                    
                    if result and result[0] and result[1]:
                        min_date, max_date = result
                        
                        # 设置开始日期为最早日期
                        start_date = QDate.fromString(min_date.strftime("%Y-%m-%d"), "yyyy-MM-dd")
                        self.start_date_edit.setDate(start_date)
                        
                        # 设置结束日期为最晚日期
                        end_date = QDate.fromString(max_date.strftime("%Y-%m-%d"), "yyyy-MM-dd")
                        self.end_date_edit.setDate(end_date)
                        
                        print(f"设置日期范围: {min_date.strftime('%Y-%m-%d')} 至 {max_date.strftime('%Y-%m-%d')}")
                    else:
                        # 如果没有数据，使用默认日期范围
                        self.set_default_date_range()
                        
                finally:
                    if conn:
                        self.db_connector.release_connection(conn)
            else:
                # 如果数据库连接失败，使用默认日期范围
                self.set_default_date_range()
                
        except Exception as e:
            print(f"加载日期范围错误: {str(e)}")
            traceback.print_exc()
            
            # 出错时使用默认日期范围
            self.set_default_date_range()
            
    def set_default_date_range(self):
        """设置默认日期范围"""
        # 设置默认开始日期为一年前
        start_date = QDate.currentDate().addYears(-1)
        self.start_date_edit.setDate(start_date)
        
        # 设置默认结束日期为当前日期
        end_date = QDate.currentDate()
        self.end_date_edit.setDate(end_date)
        
    def on_data_granularity_changed(self, data_level):
        """数据粒度变更事件处理"""
        try:
            # 获取当前选择的基金代码
            fund_code = self.fund_combo.currentData()
            if not fund_code:
                fund_name = self.fund_combo.currentText()
                fund_code = fund_name.split('.')[0]
            
            # 更新日期范围
            self.load_date_range_for_fund(fund_code)
            
        except Exception as e:
            print(f"数据粒度变更处理错误: {str(e)}")
            traceback.print_exc()
            
    def closeEvent(self, event):
        """窗口关闭事件处理"""
        try:
            # 关闭数据库连接
            if self.db_connector:
                self.db_connector.close_all()
                
            # 接受关闭事件
            event.accept()
        except Exception as e:
            print(f"窗口关闭事件处理错误: {str(e)}")
            traceback.print_exc()
            event.accept()
    
    def create_backtest_module(self, fund_name, strategy_name, start_date, end_date):
        """创建单个回测模块
        
        Args:
            fund_name: 基金名称
            strategy_name: 策略名称
            start_date: 开始日期
            end_date: 结束日期
            
        Returns:
            QWidget: 回测模块组件
        """
        # 导入必要的库
        from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
        from matplotlib.figure import Figure
        
        # 创建整个模块的容器 - 不使用QFrame，改用QWidget以去除所有边框
        module = QWidget()
        module.setStyleSheet("""
            QWidget {
                background-color: white;
                border: none;
            }
        """)
        
        # 创建主布局，增加间距
        module_layout = QVBoxLayout(module)
        module_layout.setContentsMargins(25, 22, 25, 22)  # 增加外边距
        module_layout.setSpacing(15)  # 增加元素间距
        
        # 1. 顶部信息行 - 移除边框
        info_widget = QWidget()
        info_layout = QHBoxLayout(info_widget)
        info_layout.setContentsMargins(0, 0, 0, 0)
        info_layout.setSpacing(26)
        
        # 基金和策略信息
        date_range = f"{start_date}至{end_date}"
        info_text = QLabel(f"基金: {fund_name}    策略: {strategy_name}    时间周期: {date_range}")
        info_text.setStyleSheet("font-size: 12px; background-color: white;")
        info_layout.addWidget(info_text)
        
        # 添加弹性空间
        info_layout.addStretch(1)
        
        # 添加交易详情按钮
        detail_btn = QPushButton("交易详情")
        detail_btn.setStyleSheet("""
            QPushButton {
                border: 1px solid #CCCCCC;
                border-radius: 3px;
                padding: 6px 12px;
                background-color: #f0f0f0;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
            }
        """)
        detail_btn.setFixedWidth(70)
        detail_btn.clicked.connect(self.show_trade_details)
        info_layout.addWidget(detail_btn)
        
        # 添加顶部信息行到模块
        module_layout.addWidget(info_widget)
        
        # 2. 图表区域 - 增加高度并完全移除边框
        # 直接创建FigureCanvas作为图表控件
        fig = Figure(figsize=(8, 2.66), dpi=100, facecolor='white')
        fig.subplots_adjust(left=0.02, right=0.98, top=0.95, bottom=0.15)
        chart_widget = FigureCanvas(fig)
        chart_widget.setFixedHeight(270)  # 微调高度以适应整体布局
        chart_widget.setStyleSheet("""
            background-color: white;
            border: none;
            margin: 0;
        """)
        
        # 创建简单的空白图表
        ax = fig.add_subplot(111)
        ax.set_xlim(0, 1.0)
        ax.set_ylim(0, 1.0)
        ax.set_xticks([0.0, 0.2, 0.4, 0.6, 0.8, 1.0])
        ax.set_yticks([0.0, 0.2, 0.4, 0.6, 0.8, 1.0])
        ax.grid(True, linestyle='-', color='#E5E5E5', alpha=0.7)
        
        # 完全移除所有边框
        for spine in ax.spines.values():
            spine.set_visible(False)
            
        # 完全移除所有刻度标记，但保留标签
        ax.tick_params(axis='both', which='both', length=0)
        
        # 创建图表容器，使用与顶部信息行相同的布局约束
        chart_container = QWidget()
        chart_container.setStyleSheet("background-color: white;")
        chart_layout = QVBoxLayout(chart_container)
        chart_layout.setContentsMargins(0, 0, 0, 0)  # 无边距，确保图表填满容器
        chart_layout.addWidget(chart_widget)
        
        # 添加图表到模块
        module_layout.addWidget(chart_container)
        
        # 3. 底部结果信息行 - 移除边框
        result_widget = QWidget()
        result_layout = QHBoxLayout(result_widget)
        result_layout.setContentsMargins(0, 0, 0, 0)
        result_layout.setSpacing(5)
        
        # 创建结果标签
        result_text = QLabel("正在准备回测...")
        result_text.setStyleSheet("font-size: 12px; background-color: white;")
        result_layout.addWidget(result_text)
        
        # 添加弹性空间
        result_layout.addStretch(1)
        
        # 添加底部结果行到模块
        module_layout.addWidget(result_widget)
        
        # 添加外边框（只在模块的最外层）- 使用淡灰色边框
        outer_frame = QFrame()
        outer_frame.setFrameShape(QFrame.Box)
        outer_frame.setLineWidth(1)
        outer_frame.setStyleSheet("border: 1px solid #E0E0E0; position: relative;")  # 使用更淡的灰色
        
        # 创建外层布局
        outer_layout = QVBoxLayout(outer_frame)
        outer_layout.setContentsMargins(0, 0, 0, 0)  # 移除额外边距
        outer_layout.setSpacing(0)
        
        # 添加模块到外层布局
        outer_layout.addWidget(module)
        
        # 创建关闭按钮并添加到右上角
        close_btn = QPushButton("×")
        close_btn.setToolTip("关闭此回测模块")
        close_btn.setFixedSize(20, 20)
        close_btn.setStyleSheet("""
            QPushButton {
                border: none;
                background-color: transparent;
                color: #999999;
                font-weight: bold;
                font-size: 16px;
                position: absolute;
                top: 5px;
                right: 5px;
            }
            QPushButton:hover {
                color: #FF0000;
            }
        """)
        close_btn.clicked.connect(lambda: self.remove_backtest_module(outer_frame))
        
        # 使用绝对定位将关闭按钮放在右上角
        close_btn.setParent(outer_frame)
        close_btn.move(outer_frame.width() - 25, 5)  # 右上角位置
        
        # 确保当父容器调整大小时重新定位按钮
        outer_frame.resizeEvent = lambda event: close_btn.move(outer_frame.width() - 25, 5)
        
        # 存储图表控件和结果标签的引用，以便后续更新
        outer_frame.chart_widget = chart_widget
        outer_frame.chart_layout = chart_layout  # 保存布局引用，以便后续更新图表
        outer_frame.result_text = result_text
        
        # 添加取消按钮
        cancel_button = QPushButton("取消回测")
        cancel_button.setStyleSheet("""
            QPushButton {
                border: 1px solid #CCCCCC;
                border-radius: 3px;
                padding: 6px 12px;
                background-color: #f0f0f0;
                color: #FF0000;
            }
            QPushButton:hover {
                background-color: #e0e0e0;
            }
        """)
        cancel_button.clicked.connect(lambda: self._cancel_backtest(outer_frame))
        result_layout.addWidget(cancel_button)
        outer_frame.cancel_button = cancel_button
        
        return outer_frame
    
    def create_empty_chart(self, chart_widget):
        """创建简单的空白图表，没有任何导航按钮
        
        Args:
            chart_widget: 图表控件
        """
        try:
            import numpy as np
            import matplotlib.pyplot as plt
            from matplotlib.figure import Figure
            from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
            
            # 创建自定义图表，使用相对尺寸比例
            fig = Figure(figsize=(8, 2.66), dpi=100, facecolor='white')
            
            # 调整布局 - 确保没有顶部空间给标题
            fig.subplots_adjust(left=0.02, right=0.98, top=0.95, bottom=0.15)
            
            canvas = FigureCanvas(fig)
            ax = fig.add_subplot(111)
            
            # 设置X和Y轴的范围
            ax.set_xlim(0, 1.0)
            ax.set_ylim(0, 1.0)
            
            # 设置刻度值 - 确保首尾对齐
            ax.set_xticks([0.0, 0.2, 0.4, 0.6, 0.8, 1.0])
            ax.set_yticks([0.0, 0.2, 0.4, 0.6, 0.8, 1.0])
            
            # 设置网格线 - 使用浅灰色
            ax.grid(True, linestyle='-', color='#E5E5E5', alpha=0.7)
            
            # 完全移除所有边框
            for spine in ax.spines.values():
                spine.set_visible(False)
            
            # 完全移除所有刻度标记，但保留标签
            ax.tick_params(axis='both', which='both', 
                          length=0, width=0, 
                          labelbottom=True, labelleft=True,
                          bottom=False, top=False, left=False, right=False,
                          pad=3)
            
            # 使用简单的方式添加标题，避免使用可能产生小黑框的方法
            ax.text(0.5, 0.98, '净值走势图', 
                   transform=ax.transAxes,
                   ha='center', va='top',
                   fontsize=10, color='black')
            
            # 将图表添加到ChartWidget
            chart_widget.setFigure(fig)
            
            # 设置图表响应容器大小变化
            chart_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
            canvas.setMinimumWidth(300)  # 设置最小宽度
            
        except Exception as e:
            print(f"创建空白图表错误: {str(e)}")
            traceback.print_exc()
    
    def add_backtest_module(self, fund_name, strategy_name, start_date, end_date):
        """添加一个新的回测模块到容器
        
        Args:
            fund_name: 基金名称
            strategy_name: 策略名称
            start_date: 开始日期
            end_date: 结束日期
        """
        try:
            # 创建新模块
            module = self.create_backtest_module(fund_name, strategy_name, start_date, end_date)
            
            # 添加到容器中，确保添加在stretch之前
            self.strategy_container_layout.insertWidget(
                self.strategy_container_layout.count() - 1,  # 在stretch之前插入
                module
            )
            
            # 让模块之间有更大的间距
            if self.strategy_container_layout.count() > 2:  # 如果有多个模块
                self.strategy_container_layout.setSpacing(15)  # 增加模块间距
            
        except Exception as e:
            print(f"添加回测模块错误: {str(e)}")
            traceback.print_exc()
            
    def remove_backtest_module(self, module):
        """移除回测模块
        
        Args:
            module: 要移除的模块
        """
        try:
            # 从布局中移除模块
            self.strategy_container_layout.removeWidget(module)
            
            # 删除模块
            module.deleteLater()
            
            # 如果没有模块了，重置间距
            if self.strategy_container_layout.count() <= 2:  # 只剩下stretch和添加按钮
                self.strategy_container_layout.setSpacing(0)
                
        except Exception as e:
            print(f"移除回测模块错误: {str(e)}")
            traceback.print_exc()
            
    def update_backtest_chart(self, module, stock_data, current_index=None, buy_signals=None, sell_signals=None):
        """更新回测图表
        
        Args:
            module: 回测模块
            stock_data: 股票数据
            current_index: 当前索引，用于在图表上标记当前位置
            buy_signals: 买入信号列表
            sell_signals: 卖出信号列表
        """
        # 导入必要的库
        from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
        
        print(f"开始更新图表: 数据长度={len(stock_data) if stock_data is not None else 0}, 买入信号={len(buy_signals) if buy_signals else 0}, 卖出信号={len(sell_signals) if sell_signals else 0}")
        
        if module is None:
            print("错误: 模块为空，无法更新图表")
            return
            
        # 直接从模块获取图表控件
        if hasattr(module, 'chart_widget'):
            chart_widget = module.chart_widget
            print("从模块属性中找到图表控件")
        else:
            # 如果没有直接属性，尝试从子控件中查找
            chart_widget = None
            for child in module.children():
                if isinstance(child, FigureCanvas):
                    chart_widget = child
                    print("从模块子控件中找到图表控件")
                    break
            
            if not chart_widget:
                print("未找到图表控件，尝试重新创建...")
                from matplotlib.figure import Figure
                
                # 创建图表控件
                fig = Figure(figsize=(8, 2.66), dpi=100, facecolor='white')
                chart_widget = FigureCanvas(fig)
                
                # 添加到模块布局
                if hasattr(module, 'chart_layout'):
                    module.chart_layout.addWidget(chart_widget)
                    print("已重新创建图表控件并添加到布局")
                else:
                    print("模块没有chart_layout属性，无法添加图表控件")
                    return
        
        if stock_data is None or stock_data.empty:
            print("警告: 股票数据为空，创建空图表")
            self.create_empty_chart(chart_widget)
            return
            
            # 更新完整图表，统一一次绘制
            self.update_backtest_chart(module, data, len(data)-1, buy_signals, sell_signals)
            
            # 强制再次处理事件，确保UI更新
            QApplication.processEvents()
            
            # 更新状态栏，显示最终结果
            self.statusBar.showMessage(f"回测完成: 买入信号 {len(buy_signals)} 个，卖出信号 {len(sell_signals)} 个，收益率 {total_profit_rate:.2f}%")
        except Exception as e:
            print(f"回测完成回调处理错误: {str(e)}")
            traceback.print_exc()
            self.statusBar.showMessage(f"回测完成，但图表绘制失败: {str(e)}")
    
    def _on_backtest_error(self, error_message):
        """回测错误回调"""
        QMessageBox.warning(self, "回测错误", error_message)
    
    def _cancel_backtest(self, module):
        """取消回测"""
        if hasattr(module, 'backtest_worker'):
            # 确认是否取消
            reply = QMessageBox.question(
                self, 
                "取消回测", 
                "确定要取消当前回测吗？", 
                QMessageBox.Yes | QMessageBox.No, 
                QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                # 取消回测
                module.backtest_worker.cancel()
                self.statusBar.showMessage("正在取消回测...")
    
    def save_backtest_results(self, fund_code, start_date, end_date, initial_capital, final_capital, total_profit, total_profit_rate, strategy_id, strategy_name):
        """保存回测结果到数据库
        
        Args:
            fund_code: 基金代码
            start_date: 开始日期
            end_date: 结束日期
            initial_capital: 初始资金
            final_capital: 最终资金
            total_profit: 总收益
            total_profit_rate: 总收益率
            strategy_id: 策略ID
            strategy_name: 策略名称
            
        Returns:
            int: 回测ID，如果保存失败则返回None
        """
        try:
            if not self.db_connector:
                print("无法保存回测结果：数据库连接器未初始化")
                return None
                
            conn = self.db_connector.get_connection()
            if not conn:
                print("无法获取数据库连接")
                return None
                
            try:
                cursor = conn.cursor()
                
                # 插入回测结果
                cursor.execute("""
                    INSERT INTO backtest_results 
                    (stock_code, start_date, end_date, initial_capital, final_capital, 
                    total_profit, total_profit_rate, backtest_time, strategy_id, strategy_name)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, NOW(), %s, %s)
                    RETURNING id
                """, (
                    fund_code, start_date, end_date, initial_capital, final_capital,
                    total_profit, total_profit_rate, strategy_id, strategy_name
                ))
                
                # 获取新插入的回测ID
                backtest_id = cursor.fetchone()[0]
                
                # 提交事务
                conn.commit()
                
                print(f"成功保存回测结果，ID: {backtest_id}")
                return backtest_id
                
            except Exception as e:
                if conn:
                    conn.rollback()
                print(f"保存回测结果失败: {str(e)}")
                traceback.print_exc()
                return None
            finally:
                if conn:
                    self.db_connector.release_connection(conn)
                    
        except Exception as e:
            print(f"保存回测结果过程中出错: {str(e)}")
            traceback.print_exc()
            return None 

    def _find_closest_date(self, target_date, date_list):
        """找到列表中与目标日期最接近的日期
        
        Args:
            target_date: 目标日期
            date_list: 日期列表
            
        Returns:
            最接近的日期
        """
        try:
            if not date_list:
                return None
                
            # 将target_date确保为datetime对象
            if isinstance(target_date, str):
                try:
                    target_date = pd.to_datetime(target_date)
                except:
                    print(f"无法将目标日期转换为datetime: {target_date}")
                    return None
                
            # 创建一个有效的datetime列表用于比较
            valid_dates = []
            valid_indices = []
            
            for i, d in enumerate(date_list):
                # 跳过非日期类型
                if not hasattr(d, 'strftime') and not isinstance(d, str):
                    continue
                    
                # 将字符串转换为datetime
                if isinstance(d, str):
                    try:
                        dt = pd.to_datetime(d)
                        valid_dates.append(dt)
                        valid_indices.append(i)
                    except:
                        continue
                else:
                    # 已经是datetime类型
                    valid_dates.append(d)
                    valid_indices.append(i)
            
            if not valid_dates:
                print(f"没有找到有效的日期进行比较")
                return None
                
            # 找到时间差最小的日期
            min_diff = float('inf')
            closest_idx = -1
            
            for i, dt in enumerate(valid_dates):
                # 安全地计算时间差（秒）
                try:
                    if hasattr(dt, 'timestamp') and hasattr(target_date, 'timestamp'):
                        diff = abs(dt.timestamp() - target_date.timestamp())
                        if diff < min_diff:
                            min_diff = diff
                            closest_idx = i
                except Exception as e:
                    print(f"计算时间差异时出错: {str(e)}, 类型: {type(dt)} vs {type(target_date)}")
                    continue
            
            if closest_idx >= 0:
                orig_idx = valid_indices[closest_idx]
                print(f"找到最接近日期: 目标={target_date}, 匹配={date_list[orig_idx]}, 差异={min_diff}秒")
                return date_list[orig_idx]
            
            return None
            
        except Exception as e:
            print(f"查找最接近日期出错: {str(e)}")
            return None 

    def _get_relative_position(self, signal_time, date_list):
        """计算信号时间在日期列表中的相对位置（0.0到1.0之间）
        
        Args:
            signal_time: 信号时间
            date_list: 日期列表
            
        Returns:
            相对位置（0.0-1.0之间的浮点数），如果无法计算则返回-1
        """
        try:
            if not date_list or len(date_list) == 0:
                return -1
                
            # 确保信号时间是datetime对象
            if isinstance(signal_time, str):
                try:
                    signal_time = pd.to_datetime(signal_time)
                except:
                    return -1
            
            # 获取列表中第一个和最后一个有效日期
            first_date = None
            last_date = None
            
            for date in date_list:
                if hasattr(date, 'strftime') or isinstance(date, str):
                    try:
                        if isinstance(date, str):
                            dt = pd.to_datetime(date)
                        else:
                            dt = date
                            
                        if first_date is None or dt < first_date:
                            first_date = dt
                        if last_date is None or dt > last_date:
                            last_date = dt
                    except:
                        continue
            
            if first_date is None or last_date is None:
                return -1
                
            # 确保信号时间在日期范围内
            if signal_time < first_date:
                return 0.0  # 如果信号时间早于第一个日期，放在开头
            if signal_time > last_date:
                return 1.0  # 如果信号时间晚于最后一个日期，放在结尾
            
            # 计算相对位置
            total_range = (last_date - first_date).total_seconds()
            if total_range == 0:
                return 0.5  # 避免除以零
                
            signal_position = (signal_time - first_date).total_seconds()
            rel_pos = signal_position / total_range
            
            return min(max(rel_pos, 0.0), 1.0)  # 确保结果在0到1之间
            
        except Exception as e:
            print(f"计算相对位置出错: {str(e)}")
            return -1

    def _compare_date_formats(self, signal_date, chart_dates):
        """比较信号日期和图表日期的格式，帮助诊断问题
        
        Args:
            signal_date: 信号日期
            chart_dates: 图表日期列表
            
        Returns:
            包含比较结果的字典
        """
        result = {
            "signal_date_type": str(type(signal_date)),
            "chart_dates_types": [],
            "same_type_found": False,
            "potential_matches": []
        }
        
        # 检查类型
        for i, date in enumerate(chart_dates[:10]):
            date_type = str(type(date))
            if date_type not in result["chart_dates_types"]:
                result["chart_dates_types"].append(date_type)
                
            # 检查是否有相同类型
            if type(signal_date) == type(date):
                result["same_type_found"] = True
                
        # 尝试各种格式化比较
        try:
            if hasattr(signal_date, 'strftime'):
                signal_str = signal_date.strftime("%Y-%m-%d")
                for i, date in enumerate(chart_dates[:20]):
                    if hasattr(date, 'strftime'):
                        chart_str = date.strftime("%Y-%m-%d")
                        if signal_str == chart_str:
                            result["potential_matches"].append(f"匹配日期在索引 {i}: {date}")
                    elif isinstance(date, str) and signal_str in date:
                        result["potential_matches"].append(f"部分匹配字符串在索引 {i}: {date}")
        except Exception as e:
            result["formatting_error"] = str(e)
            
        return result